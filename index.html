
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Package Counter â€“ Back Camera + Capture</title>
  <!-- React + ReactDOM (UMD) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Tailwind via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Babel (to run JSX directly) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- ZXing (barcodes + QR) -->
  <script src="https://unpkg.com/@zxing/library@0.20.0"></script>
  <style>
    video { transform: scaleX(-1); } /* mirror preview for natural alignment */
  </style>
</head>
<body class="bg-slate-50">
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useRef, useState } = React;
    const nowISO = () => new Date().toISOString();
    const persistKey = "pkgCounterBackCaptureV1";

    function App() {
      const [sessionName, setSessionName] = useState("");
      const [sender, setSender] = useState("");
      const [packages, setPackages] = useState([]);
      const [count, setCount] = useState(0);
      const [devices, setDevices] = useState([]);
      const [selectedDeviceId, setSelectedDeviceId] = useState("");
      const [scanning, setScanning] = useState(false);
      const [lastCode, setLastCode] = useState("");
      const [note, setNote] = useState("");

      const videoRef = useRef(null);
      const canvasRef = useRef(null);
      const idRef = useRef(null);
      const codeReaderRef = useRef(null);
      const streamRef = useRef(null);

      // Load state
      useEffect(() => {
        try {
          const raw = localStorage.getItem(persistKey);
          if (raw) {
            const s = JSON.parse(raw);
            setSessionName(s.sessionName || "");
            setSender(s.sender || "");
            setPackages(s.packages || []);
            setCount(s.count || 0);
          }
        } catch {}
      }, []);

      // Save state
      useEffect(() => {
        const s = { sessionName, sender, packages, count };
        try { localStorage.setItem(persistKey, JSON.stringify(s)); } catch {}
      }, [sessionName, sender, packages, count]);

      // List video input devices
      const refreshDevices = async () => {
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const cams = devices.filter(d => d.kind === "videoinput");
          setDevices(cams);
          // try pick a back camera by label keywords
          const back = cams.find(d => /back|rear|traseira|environment/i.test(d.label));
          if (back && !selectedDeviceId) setSelectedDeviceId(back.deviceId);
          if (!back && cams[0] && !selectedDeviceId) setSelectedDeviceId(cams[0].deviceId);
        } catch (e) {
          console.warn("enumerateDevices failed:", e);
        }
      };

      // Start camera with back-facing preference
      const startCamera = async () => {
        try {
          await stopCamera();
          const constraints = selectedDeviceId
            ? { video: { deviceId: { exact: selectedDeviceId } } }
            : { video: { facingMode: { ideal: "environment" } } };
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          streamRef.current = stream;
          videoRef.current.srcObject = stream;
          await videoRef.current.play();
          setScanning(true);
          refreshDevices(); // to reveal labels after permission
        } catch (e) {
          alert("Camera error: " + (e?.message || e));
        }
      };

      const stopCamera = async () => {
        try {
          const stream = streamRef.current || (videoRef.current && videoRef.current.srcObject);
          if (stream) {
            stream.getTracks().forEach(t => t.stop());
          }
        } catch {}
        if (videoRef.current) videoRef.current.srcObject = null;
        setScanning(false);
      };

      // Beep feedback
      const beep = () => {
        try {
          const ctx = new (window.AudioContext || window.webkitAudioContext)();
          const o = ctx.createOscillator();
          const g = ctx.createGain();
          o.type = "sine"; o.frequency.value = 880;
          o.connect(g); g.connect(ctx.destination);
          g.gain.setValueAtTime(0.0001, ctx.currentTime);
          g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime + 0.01);
          o.start();
          setTimeout(()=>{ g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.04); o.stop(ctx.currentTime + 0.06); }, 60);
        } catch {}
      };

      const inc = (id, note="") => {
        const pkg = { id, note, sender: sender || "-", ts: nowISO() };
        setPackages(arr => [pkg, ...arr]);
        setCount(c => c + 1);
        try { navigator.vibrate && navigator.vibrate(10); } catch {}
        beep();
      };

      const dec = () => {
        setPackages(arr => arr.slice(1));
        setCount(c => Math.max(0, c - 1));
      };

      const reset = () => {
        if (confirm("Reset session? This clears the counter and list.")) {
          setPackages([]);
          setCount(0);
        }
      };

      const exportCSV = () => {
        const headers = ["session","sender","index","package_id","note","timestamp_iso"];
        const rows = packages.slice().reverse().map((p,i)=>[sessionName, sender, i+1, p.id, p.note, p.ts]);
        const csv = [headers.join(","), ...rows.map(r => r.map(v => `"${String(v).replaceAll('"','""')}"`).join(","))].join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = "packages.csv"; a.click();
        URL.revokeObjectURL(url);
      };

      // Capture photo, decode barcode from still image, then +1
      const captureAndDecode = async () => {
        if (!videoRef.current) return;
        // draw frame to canvas
        const v = videoRef.current;
        const c = canvasRef.current;
        const w = v.videoWidth;
        const h = v.videoHeight;
        if (!w || !h) { alert("Camera not ready yet."); return; }
        c.width = w; c.height = h;
        const ctx = c.getContext("2d");
        // Because preview is mirrored, flip back when capturing
        ctx.save();
        ctx.scale(-1, 1);
        ctx.drawImage(v, -w, 0, w, h);
        ctx.restore();
        const dataUrl = c.toDataURL("image/png");

        try {
          // Use ZXing to decode the still image
          const ZX = window.ZXing;
          const codeReader = codeReaderRef.current || new ZX.BrowserMultiFormatReader();
          codeReaderRef.current = codeReader;
          const result = await codeReader.decodeFromImageUrl(dataUrl);
          if (result && result.getText()) {
            const text = result.getText();
            setLastCode(text);
            inc(text);
          } else {
            alert("No barcode detected. Try moving closer and ensuring good lighting.");
          }
        } catch (e) {
          alert("Could not read the barcode. Tip: fill the frame with the code and ensure good lighting.");
          console.warn(e);
        }
      };

      useEffect(() => () => { stopCamera(); }, []);

      return (
        <div className="p-4 max-w-4xl mx-auto grid gap-4">
          <h1 className="text-2xl font-bold">Package Counter â€“ Back Camera + Capture</h1>

          <div className="bg-white p-4 rounded shadow grid gap-2">
            <div className="grid md:grid-cols-2 gap-2">
              <div>
                <label className="text-sm">Session</label>
                <input className="border p-2 w-full" value={sessionName} onChange={e=>setSessionName(e.target.value)} placeholder="Route/Dock/Shift" />
              </div>
              <div>
                <label className="text-sm">Sender</label>
                <input className="border p-2 w-full" value={sender} onChange={e=>setSender(e.target.value)} placeholder="Warehouse name" />
              </div>
            </div>
          </div>

          <div className="bg-white p-4 rounded shadow grid gap-2">
            <div className="flex flex-wrap items-center gap-2">
              <select className="border p-2" value={selectedDeviceId} onChange={e=>setSelectedDeviceId(e.target.value)}>
                <option value="">Auto (Back camera)</option>
                {devices.map(d => <option key={d.deviceId} value={d.deviceId}>{d.label || d.deviceId}</option>)}
              </select>
              {!scanning ? (
                <button onClick={startCamera} className="bg-emerald-600 text-white px-4 py-2 rounded">Start camera</button>
              ) : (
                <button onClick={stopCamera} className="bg-gray-700 text-white px-4 py-2 rounded">Stop camera</button>
              )}
              <button onClick={refreshDevices} className="bg-gray-200 px-3 py-2 rounded">Refresh cameras</button>
            </div>

            <div className="grid gap-2">
              <video ref={videoRef} className="w-full rounded border bg-black" playsInline muted></video>
              <button onClick={captureAndDecode} className="bg-blue-600 text-white px-4 py-3 rounded text-lg">ðŸ“¸ Capture & decode</button>
              <div className="text-xs text-gray-600">Last code: <span className="font-mono">{lastCode || "â€”"}</span></div>
            </div>
            <canvas ref={canvasRef} className="hidden"></canvas>
          </div>

          <div className="bg-white p-4 rounded shadow grid grid-cols-2 gap-2">
            <button onClick={()=>setPackages(arr=>arr.slice(1)) || setCount(c=>Math.max(0,c-1))} className="bg-gray-200 p-4 text-xl rounded">-1</button>
            <button onClick={()=>inc("#"+(packages.length+1))} className="bg-blue-600 text-white p-4 text-xl rounded">+1 (manual)</button>
            <button onClick={reset} className="bg-red-500 text-white p-3 rounded col-span-2">Reset</button>
          </div>

          <div className="flex justify-between items-center">
            <div>Total: <span className="font-bold">{count}</span></div>
            <div>Sender: {sender || "â€“"}</div>
          </div>

          <div className="bg-white p-4 rounded shadow">
            <div className="flex justify-between mb-2">
              <h2 className="font-bold">Packages ({packages.length})</h2>
              <button onClick={exportCSV} className="bg-gray-200 px-3 py-1 rounded">Export CSV</button>
            </div>
            {packages.length === 0 ? <p className="text-sm text-gray-500">No packages yet</p> : (
              <ul className="divide-y">
                {packages.map(p => (
                  <li key={p.ts} className="py-1 text-sm">
                    <span className="font-mono font-medium">{p.id}</span> â€“ {p.note} <span className="text-gray-400">[{new Date(p.ts).toLocaleString()}]</span>
                  </li>
                ))}
              </ul>
            )}
          </div>

          <p className="text-xs text-center text-gray-400">Back camera preferred â€¢ Use HTTPS (GitHub Pages) or localhost for camera access</p>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App/>);
  </script>
</body>
</html>
