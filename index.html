
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Package Counter â€“ Back Camera + Capture (v2)</title>
  <!-- React + ReactDOM (UMD) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Tailwind via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Babel (to run JSX directly) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- ZXing (barcodes + QR) -->
  <script src="https://unpkg.com/@zxing/library@0.20.0"></script>
  <style>
    /* no mirror to avoid confusion between preview and captured frame */
    video { object-fit: contain; }
  </style>
</head>
<body class="bg-slate-50">
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useRef, useState } = React;
    const nowISO = () => new Date().toISOString();
    const persistKey = "pkgCounterBackCaptureV2";

    function App() {
      const [sessionName, setSessionName] = useState("");
      const [sender, setSender] = useState("");
      const [packages, setPackages] = useState([]);
      const [count, setCount] = useState(0);
      const [devices, setDevices] = useState([]);
      const [selectedDeviceId, setSelectedDeviceId] = useState("");
      const [scanning, setScanning] = useState(false);
      const [lastCode, setLastCode] = useState("");
      const [note, setNote] = useState("");
      const [torchOn, setTorchOn] = useState(false);
      const [status, setStatus] = useState("");

      const videoRef = useRef(null);
      const canvasRef = useRef(null);
      const idRef = useRef(null);
      const streamRef = useRef(null);
      const trackRef = useRef(null);
      const barcodeDetectorRef = useRef(null);
      const zxingReaderRef = useRef(null);

      // Load state
      useEffect(() => {
        try {
          const raw = localStorage.getItem(persistKey);
          if (raw) {
            const s = JSON.parse(raw);
            setSessionName(s.sessionName || "");
            setSender(s.sender || "");
            setPackages(s.packages || []);
            setCount(s.count || 0);
          }
        } catch {}
      }, []);

      // Save state
      useEffect(() => {
        const s = { sessionName, sender, packages, count };
        try { localStorage.setItem(persistKey, JSON.stringify(s)); } catch {}
      }, [sessionName, sender, packages, count]);

      // Setup BarcodeDetector if available
      useEffect(() => {
        if ('BarcodeDetector' in window) {
          try {
            barcodeDetectorRef.current = new window.BarcodeDetector({
              formats: ['code_128','code_39','code_93','ean_13','ean_8','upc_a','upc_e','codabar','itf','qr_code','pdf417']
            });
          } catch (e) {
            console.warn("BarcodeDetector init failed", e);
          }
        } else {
          setStatus("BarcodeDetector not supported; falling back to ZXing.");
        }
      }, []);

      // Device list
      const refreshDevices = async () => {
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const cams = devices.filter(d => d.kind === "videoinput");
          setDevices(cams);
          // choose back camera by label if possible
          const back = cams.find(d => /back|rear|environment|traseira/i.test(d.label));
          if (back && !selectedDeviceId) setSelectedDeviceId(back.deviceId);
          if (!back && cams[0] && !selectedDeviceId) setSelectedDeviceId(cams[0].deviceId);
        } catch (e) {
          console.warn("enumerateDevices failed:", e);
        }
      };

      // Start camera with back-facing preference + try to enable torch if available
      const startCamera = async () => {
        try {
          await stopCamera();
          setStatus("Starting camera...");
          const constraints = selectedDeviceId
            ? { video: { deviceId: { exact: selectedDeviceId }, focusMode: "continuous" } }
            : { video: { facingMode: { ideal: "environment" }, focusMode: "continuous" } };
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          streamRef.current = stream;
          const track = stream.getVideoTracks()[0];
          trackRef.current = track;
          videoRef.current.srcObject = stream;
          await new Promise(res => videoRef.current.onloadedmetadata = res);
          await videoRef.current.play();
          setScanning(true);
          setStatus("Camera ready.");
          // after permission, labels become available
          refreshDevices();
        } catch (e) {
          setStatus("Camera error: " + (e?.message || e));
          alert("Camera error: " + (e?.message || e));
        }
      };

      const stopCamera = async () => {
        try {
          const stream = streamRef.current || (videoRef.current && videoRef.current.srcObject);
          if (stream) stream.getTracks().forEach(t => t.stop());
        } catch {}
        if (videoRef.current) videoRef.current.srcObject = null;
        trackRef.current = null;
        setTorchOn(false);
        setScanning(false);
      };

      // Torch toggle (if supported)
      const toggleTorch = async () => {
        try {
          const track = trackRef.current;
          if (!track) return;
          const caps = track.getCapabilities?.();
          if (caps && caps.torch) {
            await track.applyConstraints({ advanced: [{ torch: !torchOn }] });
            setTorchOn(t => !t);
          } else {
            alert("Torch (flash) not supported on this device.");
          }
        } catch (e) {
          alert("Could not toggle torch: " + (e?.message || e));
        }
      };

      // Beep feedback
      const beep = () => {
        try {
          const ctx = new (window.AudioContext || window.webkitAudioContext)();
          const o = ctx.createOscillator();
          const g = ctx.createGain();
          o.type = "sine"; o.frequency.value = 880;
          o.connect(g); g.connect(ctx.destination);
          g.gain.setValueAtTime(0.0001, ctx.currentTime);
          g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime + 0.01);
          o.start();
          setTimeout(()=>{ g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.04); o.stop(ctx.currentTime + 0.06); }, 60);
        } catch {}
      };

      const inc = (id, note="") => {
        if (!id) return;
        const pkg = { id, note, sender: sender || "-", ts: nowISO() };
        setPackages(arr => [pkg, ...arr]);
        setCount(c => c + 1);
        try { navigator.vibrate && navigator.vibrate(10); } catch {}
        beep();
      };

      // Capture still frame -> try native BarcodeDetector -> fallback to ZXing
      const captureAndDecode = async () => {
        setStatus("Capturing...");
        const v = videoRef.current;
        if (!v || v.readyState < 2) { alert("Camera not ready. Press Start camera first."); return; }
        const c = canvasRef.current;
        const w = v.videoWidth, h = v.videoHeight;
        if (!w || !h) { alert("Camera not ready yet."); return; }
        c.width = w; c.height = h;
        const ctx = c.getContext("2d", { willReadFrequently: true });
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(v, 0, 0, w, h);

        // Try a centered crop (improves reliability for small codes)
        const cropScale = 0.8; // 80% of width/height
        const cw = Math.floor(w * cropScale);
        const ch = Math.floor(h * cropScale);
        const cx = Math.floor((w - cw) / 2);
        const cy = Math.floor((h - ch) / 2);
        const crop = ctx.getImageData(cx, cy, cw, ch);

        // Draw crop into a temp canvas
        const tc = document.createElement('canvas');
        tc.width = cw; tc.height = ch;
        const tctx = tc.getContext('2d', { willReadFrequently: true });
        tctx.putImageData(crop, 0, 0);

        // 1) Native detector first
        if (barcodeDetectorRef.current) {
          try {
            const results = await barcodeDetectorRef.current.detect(tc);
            if (results && results.length) {
              const code = results[0].rawValue;
              setLastCode(code);
              inc(code);
              setStatus("Decoded with BarcodeDetector.");
              return;
            }
          } catch (e) {
            console.warn("BarcodeDetector detect failed", e);
          }
        }

        // 2) ZXing fallback using data URL from temp canvas
        try {
          if (!zxingReaderRef.current) zxingReaderRef.current = new ZXing.BrowserMultiFormatReader();
          const dataUrl = tc.toDataURL("image/png");
          const result = await zxingReaderRef.current.decodeFromImageUrl(dataUrl);
          if (result && result.getText()) {
            const text = result.getText();
            setLastCode(text);
            inc(text);
            setStatus("Decoded with ZXing.");
            return;
          }
          setStatus("No barcode found. Try closer lighting or fill the frame.");
          alert("No barcode detected. Move closer, steady the phone, and ensure good lighting.");
        } catch (e) {
          setStatus("ZXing failed to decode.");
          alert("Could not read the barcode. Tip: fill the frame with the code and ensure good lighting.");
          console.warn(e);
        }
      };

      useEffect(() => () => { stopCamera(); }, []);

      return (
        <div className="p-4 max-w-4xl mx-auto grid gap-4">
          <h1 className="text-2xl font-bold">Package Counter â€“ Back Camera + Capture (v2)</h1>
          {status && <div className="text-xs text-gray-600">{status}</div>}

          <div className="bg-white p-4 rounded shadow grid gap-2">
            <div className="grid md:grid-cols-2 gap-2">
              <div>
                <label className="text-sm">Session</label>
                <input className="border p-2 w-full" value={sessionName} onChange={e=>setSessionName(e.target.value)} placeholder="Route/Dock/Shift" />
              </div>
              <div>
                <label className="text-sm">Sender</label>
                <input className="border p-2 w-full" value={sender} onChange={e=>setSender(e.target.value)} placeholder="Warehouse name" />
              </div>
            </div>
          </div>

          <div className="bg-white p-4 rounded shadow grid gap-2">
            <div className="flex flex-wrap items-center gap-2">
              <select className="border p-2" value={selectedDeviceId} onChange={e=>setSelectedDeviceId(e.target.value)}>
                <option value="">Auto (Back)</option>
                {devices.map(d => <option key={d.deviceId} value={d.deviceId}>{d.label || d.deviceId}</option>)}
              </select>
              {!scanning ? (
                <button onClick={startCamera} className="bg-emerald-600 text-white px-4 py-2 rounded">Start camera</button>
              ) : (
                <button onClick={stopCamera} className="bg-gray-700 text-white px-4 py-2 rounded">Stop camera</button>
              )}
              <button onClick={refreshDevices} className="bg-gray-200 px-3 py-2 rounded">Refresh cameras</button>
              <button onClick={toggleTorch} className="bg-amber-500 text-white px-3 py-2 rounded">Toggle torch</button>
            </div>

            <div className="grid gap-2">
              <video ref={videoRef} className="w-full rounded border bg-black" playsInline muted></video>
              <button onClick={captureAndDecode} className="bg-blue-600 text-white px-4 py-3 rounded text-lg">ðŸ“¸ Capture & decode</button>
              <div className="text-xs text-gray-600">Last code: <span className="font-mono">{lastCode || "â€”"}</span></div>
            </div>
            <canvas ref={canvasRef} className="hidden"></canvas>
          </div>

          <div className="bg-white p-4 rounded shadow grid grid-cols-2 gap-2">
            <button onClick={()=>{ setPackages(arr=>arr.slice(1)); setCount(c=>Math.max(0,c-1)); }} className="bg-gray-200 p-4 text-xl rounded">-1</button>
            <button onClick={()=>{ const id = "#" + (packages.length + 1); setPackages(arr=>[{id, note:"", sender: sender || "-", ts: nowISO()}, ...arr]); setCount(c=>c+1); }} className="bg-blue-600 text-white p-4 text-xl rounded">+1 (manual)</button>
            <button onClick={()=>{ if(confirm('Reset session?')) { setPackages([]); setCount(0); } }} className="bg-red-500 text-white p-3 rounded col-span-2">Reset</button>
          </div>

          <div className="flex justify-between items-center">
            <div>Total: <span className="font-bold">{count}</span></div>
            <div>Sender: {sender || "â€“"}</div>
          </div>

          <div className="bg-white p-4 rounded shadow">
            <div className="flex justify-between mb-2">
              <h2 className="font-bold">Packages ({packages.length})</h2>
              <button onClick={()=>{
                const headers = ["session","sender","index","package_id","note","timestamp_iso"];
                const rows = packages.slice().reverse().map((p,i)=>[sessionName, sender, i+1, p.id, p.note||"", p.ts]);
                const csv = [headers.join(","), ...rows.map(r => r.map(v => `"${String(v).replaceAll('"','""')}"`).join(","))].join("\\n");
                const blob = new Blob([csv], { type: "text/csv" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url; a.download = "packages.csv"; a.click();
                URL.revokeObjectURL(url);
              }} className="bg-gray-200 px-3 py-1 rounded">Export CSV</button>
            </div>
            {packages.length === 0 ? <p className="text-sm text-gray-500">No packages yet</p> : (
              <ul className="divide-y">
                {packages.map(p => (
                  <li key={p.ts} className="py-1 text-sm">
                    <span className="font-mono font-medium">{p.id}</span> <span className="text-gray-400">[{new Date(p.ts).toLocaleString()}]</span>
                  </li>
                ))}
              </ul>
            )}
          </div>

          <p className="text-xs text-center text-gray-400">Back camera preferred â€¢ Use HTTPS (GitHub Pages) or localhost for camera access</p>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App/>);
  </script>
</body>
</html>
